{
  "hash": "0decdac58cab2d9a83a655e22c3f8ec0",
  "result": {
    "markdown": "---\ntitle: \"Showcasing the dplyr case_when() and case_match() Functions\"\ndescription: |\n  While reading Effective Pandas 2 by Matt Harrison, I learned about the new .case_when method in Pandas 2, which is a total life changer for pandas users who have longed for such a function for a long time. However, as an R programmer, I decided to review the dplyr case_when() documentation and learned that this \"lifesaving\" function has been updated.  \ncategories:\n  - Data Science \n  - Data Wrangling\n  - R\nauthor: Alier Reng\ndate: 2024-01-04\ndate-format: \"D MMMM YYYY\"\nimage: images/case_when_img.png\nimage-alt: case_when() function\ntoc: true\nfilters:\n  - lightbox\nlightbox: auto\n\ncode-block-bg: true\ncode-block-border-left: \"#31BAE9\"\n---\n\n\n# Motivation\n\nWhile reading **Effective Pandas 2** by **Matt Harrison**, I learned about the new `.case_when()` method in **Pandas 2**, which is a total life changer for `pandas` users who have longed for such a function for a long time.\nHowever, as an R programmer, I decided to review the `dplyr case_when()` documentation and learned that this **lifesaving** function has been updated.\nThe recently released version of the `case_when()` function now includes the following arguments:\n\n> case_when(..., .default = NULL, .ptype = NULL, .size = NULL)\n\nYou can read more about `case_when()` function [here!](https://dplyr.tidyverse.org/reference/case_when.html)\n\n# Introduction\n\nThe `case_when()` and `case_match()` functions from the dplyr package provide a flexible way to create conditional statements based on multiple conditions.\nIn this tutorial, we showcase these two functions and conclude with a bonus section highlighting the `separate_wider_delim()` function from the `tidyr` package.\n\nThe [dplyr website](https://dplyr.tidyverse.org/reference/case_when.html) describes the amazing `case_when()` function as follows:\n\n> This function allows you to vectorise multiple [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.html) statements.\n> Each case is evaluated sequentially and the first match for each element determines the corresponding value in the output vector.\nIf no cases match, the `.default` is used as a final \"else\" statment.\n\n> `case_when()` is an R equivalent of the SQL \"searched\" `CASE WHEN` statement.\n\n# Getting Started\n\n## Loading the Required Libraries\n\nWe will load the entire tidyverse meta-package (which contains 9 packages) for this tutorial, although we will only use the `dplyr`, `tidyr`, and `stringr` packages. Additionally, we will suppress warnings and notifications by setting the warning and message options to false, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Loading the dataset\nWe will use the `vroom` package instead of the `readr` package to load the South Sudan 2008 census dataset. Even though our dataset is too small for the speed to matter, `vroom` is faster than `readr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the data -----------------\nssd_census_2008 <-\n  vroom::vroom(\n    \"ss_2008_census_data_raw.csv\",\n    show_col_types = FALSE\n  ) |>\n  select(\n    state        = `Region Name`,\n    gender       = `Variable Name`,\n    age_category = `Age Name`,\n    population   = `2008`\n  ) |>\n  filter(\n    !is.na(gender),\n    age_category != \"Total\"\n  )\n```\n:::\n\n\n# `case_when()` Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Showcase case_when() function ---------\ncase_when_tbl <-\n  ssd_census_2008 |>\n  mutate(\n    state = state |> str_to_lower(),\n    former_region = case_when(\n      str_detect(state, \"equatoria\") ~ \"Greater Equatoria\",\n      str_detect(state, \"upper nile\") ~ \"Greater Upper Nile\",\n      str_detect(state, \"unity\") ~ \"Greater Upper Nile\",\n      str_detect(state, \"jonglei\") ~ \"Greater Upper Nile\",\n      .default = \"Greater Bahr el Ghazal\"\n    )\n  ) |>\n  mutate(\n    age_category = case_when(\n      age_category %in% c(\"0 to 4\", \"5 to 9\", \"10 to 14\") ~ \"0-14\",\n      age_category %in% c(\"15 to 19\", \"20 to 24\") ~ \"15-24\",\n      age_category %in% c(\"25 to 29\", \"30 to 34\") ~ \"25-34\",\n      age_category %in% c(\"35 to 39\", \"40 to 44\") ~ \"35-44\",\n      age_category %in% c(\"45 to 49\", \"50 to 54\") ~ \"45-54\",\n      age_category %in% c(\"55 to 59\", \"60 to 64\") ~ \"55-64\",\n      .default = \"65+\"\n    )\n  ) |>\n  # Group by and summarization\n  summarize(\n    population = sum(population),\n    .by = c(former_region, state, gender, age_category)\n  )\n```\n:::\n\n\n#  `case_match()` Example\n\nAccording to the `dplyr` website, the `case_match()` function is a \"general vectorized switch().\" Below is a summary from the website:\n\n> This function allows you to vectorise multiple switch() statements. Each case is evaluated sequentially and the first match for each element determines the corresponding value in the output vector. If no cases match, the .default is used.\ncase_match() is an R equivalent of the SQL \"simple\" CASE WHEN statement.\n\n> Connection to case_when().\nWhile case_when() uses logical expressions on the left-hand side of the formula, case_match() uses values to match against .x with. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Showcase case_match() function ------\ncase_match_tbl <-\n  ssd_census_2008 |>\n  # add former regions of South Sudan\n  mutate(\n    state = str_to_lower(state),\n    # former regions\n    former_region = case_match(\n      state,\n      c(\n        \"unity\",\n        \"upper nile\",\n        \"jonglei\"\n      ) ~ \"Greater Upper Nile\",\n      c(\n        \"central equatoria\",\n        \"western equatoria\",\n        \"eastern equatoria\"\n      ) ~ \"Greater Equatoria\",\n      .default = \"Greater Bahr el Ghazal\"\n    ),\n    # age category\n    age_category = case_match(\n      age_category,\n      c(\"0 to 4\", \"5 to 9\", \"10 to 14\") ~ \"0-14\",\n      c(\"15 to 19\", \"20 to 24\") ~ \"15-24\",\n      c(\"25 to 29\", \"30 to 34\") ~ \"25-34\",\n      c(\"35 to 39\", \"40 to 44\") ~ \"35-44\",\n      c(\"45 to 49\", \"50 to 54\") ~ \"45-54\",\n      c(\"55 to 59\", \"60 to 64\") ~ \"55-64\",\n      .default = \"65+\"\n    )\n  )\n```\n:::\n\n\nUsing the same dataset, the preceding code snippets showed how to implement both the `case_when()` and `case_match()` functions. Here, it is vividly clear that these two functions are similar, but `case_match()` involves less typing, and it seems to be a bit cleaner than the `case_when()`.\n\n# Bonus Tip\n\nIn this final section, as a bonus, we'll throw in the new updates about the `separate()` function from the `tidyr` package. Below is what we gleaned from the package website:\n\n> separate() has been superseded in favour of separate_wider_position() and separate_wider_delim() because the two functions make the two uses more obvious, the API is more polished, and the handling of problems is better. Superseded functions will not go away, but will only receive critical bug fixes.\n\n> Given either a regular expression or a vector of character positions, separate() turns a single character column into multiple columns.\n\n\n## Tidying Column Values with the `separate()` variants\n\nIn this section, we'll demonstrate how to use the `separate_wider_delim()` function, the most commonly used of the two variants of the `separate()` function. First, we will show how we solved the same problem previously and then show the updated variant.\n\n### We are trying to solve\nHere, we aim to separate the gender column into three new columns but only keep the middle column with gender rows. Here are the unique values currently in the gender column: \"Population, Total (Number),\" \"Population, Male (Number),\" and \"Population, Female (Number).\"\n\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Showcase the separate() function\nseparate_before_tbl <-\n  case_match_tbl |>\n  # Split gender column into: pop, gender, and other\n  separate(\n    col = gender, \n    into = c(\"pop\", \"gender\", \"other\"), \n    sep = \" \"\n  ) |>\n  # Remove extra/unwanted columns\n  select(-pop, -other) |> \n  # Remove the total rows\n  filter(gender != \"Total\") |>\n  # Group by and summarization\n  summarize(\n    population = sum(population),\n    .by = c(former_region, state, gender, age_category)\n  )\n```\n:::\n\n\nThe `separate()` function handles additional pieces with the `extra` argument, which can be set to either \"warn,\" \"drop,\" or \"merge.\" However, if there are fewer pieces, then `separate()` handles them with the `fill` argument, which can be set to either \"warn\" (this is the default option; it emits a warning and fills in the missing pieces from the right), \"right\" ('fill with missing values on the right'), and \"left\" ('fill with missing values on the left').\n\n## Now\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Showcase the separate() function\nseparate_wider_delim_tbl <-\n  case_match_tbl |>\n  # Split gender column\n  separate_wider_delim(\n    gender,\n    delim    = \" \",\n    names    = c(NA, \"gender\"),\n    too_many = \"drop\" # drop extra column\n  ) |>\n  # Remove the total rows\n  filter(gender != \"Total\") |>\n  # Group by and summarization\n  summarize(\n    population = sum(population),\n    .by = c(former_region, state, gender, age_category)\n  )\n```\n:::\n\n\n# Using the `NA`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Showcase the separate() function\nseparate_wider_delim_tbl <-\n  case_match_tbl |>\n  # Split gender column\n  separate_wider_delim(\n    gender,\n    delim    = \" \",\n    names    = c(NA, \"gender\", NA),\n    # too_many = \"drop\" # drop extra column\n  ) |>\n  # Remove the total rows\n  filter(gender != \"Total\") |>\n  # Group by and summarization\n  summarize(\n    population = sum(population),\n    .by = c(former_region, state, gender, age_category)\n  )\n```\n:::\n\n\nThe newer variants of `separate()`: `separate_wider_delim()` and `separate_wider_position()` handle fewer or extra pieces with the `too_few` and `too_many` arguments, which can be set to \"error,\" \"debug,\" \"align_start,\" or \"align_end\"; and \"error,\" \"debug,\" \"drop,\" or \"merge,\" respectively.\nFurther, a user can also set extra columns to `NA` to exclude them from the output - this is handy and saves time!\n\n# Closing Remarks\n\nIn this tutorial, we've showcased the updates to the `case_when()` function and highlighted its simplified variant, `case_match()`, which involves less typing and is much cleaner. `case_when()` has been optimized to handle `NA` beautifully well. Users can now set `.default` to `NA` without specifying each NA type.\n\nFurther, explained that `separate()` from the `tidyr` package has been superseded by its newer variants: `separate_wider_delim()`, `separate_wider_position()`, and `separate_wider_regex()`, which split a character column into multiple columns with a delimiter, fixed widths, and regular expression matches, respectively.\nWe hope you will find this tutorial helpful. If you do, please drop us a comment, share our post, and follow us on LinkedIn at **tongakuot** and YouTube at **AlierwaiDataStudio**.\n\n# References\n1. Ã‡etinkaya-Rundel, M.(2023, August 14). *What's new in the tidyverse?* YouTube. https://www.youtube.com/watch?v=AuQOy06Dlr8&t=2963s\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}