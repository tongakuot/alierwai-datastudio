{
  "hash": "ea1dfe09c65c52e4f2be2d5afded4eb1",
  "result": {
    "markdown": "---\ntitle: \"Solving R 4 Data Science, 2nd-edition: Section 25.2.5 Exercises.\"\ndescription: |\n  To practice R programming through hands-on exercises, as it is the best way to enhance your programming skills.\ncategories:\n  - Data Science \n  - R\n  - Tutorial\nauthor: Alier Reng\ndate: 2023-11-13\ndate-format: \"D MMMM YYYY\"\nimage: images/tutorial-02-img.png\nimage-alt: Solving R 4 Data Science Exercises.\ntoc: true\nfilters:\n  - lightbox\nlightbox: auto\n\ncode-block-bg: true\ncode-block-border-left: \"#31BAE9\"\n---\n\n\n# Motivation\n\nTo practice R programming through hands-on exercises, as it is the best way to enhance your programming skills.\n\nIn this tutorial, we will solve problems from Section 25.2.5 of the famous **R 4 Data Science by Hadley Wickham et al.** Let's get started!\n\n# Loading Required Libraries\n\nIn this section, we will load `tidyverse`package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n```\n:::\n\n\n# Section 25.2.5 Exercises\n\n1)  Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a dummy data\ndata <- tribble(\n  ~x, ~y, ~z,\n   2,  5,  7,\n  -8, 10, 13,\n  NA,  9,  3,\n  12, NA, 20,\n  15,  4, NA,\n  10,  1,  5,\n   6, 13, NA\n)\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n      x     y     z\n  <dbl> <dbl> <dbl>\n1     2     5     7\n2    -8    10    13\n3    NA     9     3\n4    12    NA    20\n5    15     4    NA\n6    10     1     5\n7     6    13    NA\n```\n:::\n:::\n\n\n-   Compute the Means\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert to a function\nmean(is.na(data$x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1428571\n```\n:::\n\n```{.r .cell-code}\nmean(is.na(data$y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1428571\n```\n:::\n\n```{.r .cell-code}\nmean(is.na(data$z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2857143\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function\ncalculate_mean <- function(data, vars) {\n  data |>\n    summarize(\n      across({{ vars }}, \\(x) round(mean(is.na(x)), 3))\n    )\n}\n\n# Test the mean function\ncalculate_mean(data, c(x, y, z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n      x     y     z\n  <dbl> <dbl> <dbl>\n1 0.143 0.143 0.286\n```\n:::\n:::\n\n\n-   Compute Proportions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the proportions\ndata$x / sum(data$x, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.05405405 -0.21621622          NA  0.32432432  0.40540541  0.27027027\n[7]  0.16216216\n```\n:::\n\n```{.r .cell-code}\ndata$y / sum(data$y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.11904762 0.23809524 0.21428571         NA 0.09523810 0.02380952 0.30952381\n```\n:::\n\n```{.r .cell-code}\ndata$z / sum(data$z, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1458333 0.2708333 0.0625000 0.4166667        NA 0.1041667        NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write a function\ncompute_prop <- function(data, vars) {\n  data |>\n    # We use reframe() because it returns a data frame with more than one rows\n    reframe(\n      across({{ vars }}, \\(x) x / sum(x, na.rm = TRUE))\n    )\n}\n\n# Test the mean function\ncompute_prop(data, c(x, y, z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n        x       y       z\n    <dbl>   <dbl>   <dbl>\n1  0.0541  0.119   0.146 \n2 -0.216   0.238   0.271 \n3 NA       0.214   0.0625\n4  0.324  NA       0.417 \n5  0.405   0.0952 NA     \n6  0.270   0.0238  0.104 \n7  0.162   0.310  NA     \n```\n:::\n:::\n\n\n-   Compute Percentages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute percentage\nround(data$x / sum(data$x, na.rm = TRUE) * 100, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   5.4 -21.6    NA  32.4  40.5  27.0  16.2\n```\n:::\n\n```{.r .cell-code}\nround(data$y / sum(data$y, na.rm = TRUE) * 100, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11.9 23.8 21.4   NA  9.5  2.4 31.0\n```\n:::\n\n```{.r .cell-code}\nround(data$z / sum(data$z, na.rm = TRUE) * 100, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14.6 27.1  6.2 41.7   NA 10.4   NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write a function\ncompute_percent <- function(data, vars) {\n  data |>\n    # We use reframe() because it returns a data frame with more than one rows\n    reframe(\n      across({{ vars }}, \\(x) round(x / sum(x, na.rm = TRUE) * 100, 1))\n    )\n}\n\n# Test the mean function\ncompute_percent(data, c(x, y, z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n      x     y     z\n  <dbl> <dbl> <dbl>\n1   5.4  11.9  14.6\n2 -21.6  23.8  27.1\n3  NA    21.4   6.2\n4  32.4  NA    41.7\n5  40.5   9.5  NA  \n6  27     2.4  10.4\n7  16.2  31    NA  \n```\n:::\n:::\n\n\n### Putting it Together\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write a function that combines the above three functions into one function\ncalc_mean_and_percent <- function(data, vars, digits) {\n  data |>\n    reframe(\n      across(\n        {{ vars }},\n        list(\n          mean = \\(x) mean(is.na(x)),\n          prop = \\(x) x / sum(x, na.rm = TRUE),\n          pct  = \\(x) x / sum(x, na.rm = TRUE) * 100\n        ),\n        .names = \"{.fn}_{.col}\"\n      )\n    ) |>\n    mutate(across(where(is.numeric), \\(x) round(x, {{ digits }})))\n}\n\n# Test the function:\ncalc_mean_and_percent(\n  data,\n  vars = c(x, y, z),\n  digits = 2\n) |>\n\tknitr::kable(align = \"c\")\n```\n\n::: {.cell-output-display}\n| mean_x | prop_x | pct_x  | mean_y | prop_y | pct_y | mean_z | prop_z | pct_z |\n|:------:|:------:|:------:|:------:|:------:|:-----:|:------:|:------:|:-----:|\n|  0.14  |  0.05  |  5.41  |  0.14  |  0.12  | 11.90 |  0.29  |  0.15  | 14.58 |\n|  0.14  | -0.22  | -21.62 |  0.14  |  0.24  | 23.81 |  0.29  |  0.27  | 27.08 |\n|  0.14  |   NA   |   NA   |  0.14  |  0.21  | 21.43 |  0.29  |  0.06  | 6.25  |\n|  0.14  |  0.32  | 32.43  |  0.14  |   NA   |  NA   |  0.29  |  0.42  | 41.67 |\n|  0.14  |  0.41  | 40.54  |  0.14  |  0.10  | 9.52  |  0.29  |   NA   |  NA   |\n|  0.14  |  0.27  | 27.03  |  0.14  |  0.02  | 2.38  |  0.29  |  0.10  | 10.42 |\n|  0.14  |  0.16  | 16.22  |  0.14  |  0.31  | 30.95 |  0.29  |   NA   |  NA   |\n:::\n:::\n\n\n2)  In the second variant of rescale01(), infinite values are left unchanged. Can you rewrite rescale01() so that -Inf is mapped to 0, and Inf is mapped to 1?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data frame\ndf <- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\n# Modify rescale01\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE, finite = TRUE)\n  value <- (x - rng[1]) / (rng[2] - rng[1])\n  value <- case_when(\n    value == Inf ~ 1,\n    value == -Inf ~ 0,\n    TRUE ~ round(value, 3)\n  )\n  value\n}\n\nmutate(df, across(a:d, \\(x) rescale01(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n      a     b     c     d\n  <dbl> <dbl> <dbl> <dbl>\n1 0.186 0.523 0.033 0.928\n2 0.898 1     1     1    \n3 0.477 0     0.498 0.384\n4 1     0.444 0.13  0.157\n5 0     0.398 0     0    \n```\n:::\n\n```{.r .cell-code}\nx <- c(1:10, Inf)\nrescale01(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000 1.000\n```\n:::\n:::\n\n\n3)  Given a vector of birthdates, write a function to compute the age in years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a sample dataset\ndf <-\n  tibble(\n    name = c(\"Mawan\", \"Garang\", \"Ayen\", \"Alier\"),\n    birth_date = c(\"2020-11-23\", \"1981-05-24\", \"2003-02-18\", \"N/A\")\n  )\n\n# Write function\ncalculate_birth_years <- function(df, b_date, ref_date = today()) {\n  df |>\n    mutate(\n      years_of_birth = if_else(is.na({{ b_date }}), NA_real_,\n        round(interval(ymd({{ b_date }}), ref_date) / years(1), 2)\n      )\n    )\n}\n\n# Let's test our new function\ncalculate_birth_years(df, birth_date)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `years_of_birth = if_else(...)`.\nCaused by warning:\n!  1 failed to parse.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  name   birth_date years_of_birth\n  <chr>  <chr>               <dbl>\n1 Mawan  2020-11-23            3.2\n2 Garang 1981-05-24           42.7\n3 Ayen   2003-02-18           21.0\n4 Alier  N/A                  NA  \n```\n:::\n:::\n\n\n4)  Write your own functions to compute the variance and skewness of a numeric vector. You can look up the definitions on Wikipedia or elsewhere.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a dummy data frame\na <- rnorm(n = 10000, mean = 450, sd = 150)\n\nhist(a)\n```\n\n::: {.cell-output-display}\n![](tutorial-02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write a function for calculating a variance and skewness of a numeric vector\n\ncalculate_variance <- function(x) {\n  n <- length(x)\n\n  if (n > 1) {\n    variance <- sum((x - mean(x, na.rm = TRUE))^2) / (n - 1)\n  } else {\n    NA_real_\n  }\n  variance\n}\n\n# Function to calculate the skewness of a numeric vector\ncalculate_skewness <- function(x) {\n  n <- length(x)\n\n  if (n > 2) {\n    variance <- calculate_variance(x)\n    skewness <- sum((x - mean(x, na.rm = TRUE))^3) / (n * variance^(3 / 2))\n  } else {\n    return(NA_real_)\n  }\n  round(skewness, 5)\n}\n\n\n# Kurtosis\ncalculate_kurtosis <- function(x) {\n  # Calculate sample mean\n  avg <- mean(x)\n\n  # Calculate sample kurtosis\n  n <- length(x)\n  kurtosis <- (sum((x - avg)^4) / n) / ((sum((x - avg)^2) / n)^2) - 3\n\n  kurtosis\n}\n\ncalculate_kurtosis(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.05604487\n```\n:::\n:::\n\n\n# Conclusion\n\nIn this tutorial, we walked you through the steps for answering section 25.3.5 exercises from R for Data Science, 2nd edition by Wickham et al., demonstrating, where possible, different approaches for answering these questions.\nOur work highlighted some ways to solve these exercises; however, there are many ways one could solve them.\nPlease try them and share your answers with us and our readers.\n\n**Happy Coding** 💪.\n",
    "supporting": [
      "tutorial-02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}